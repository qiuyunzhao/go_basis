package main

import (
	"fmt"
)

//-------------------------------------------- 父类1 --------------------------------------------------------------------
type A struct {
	Name string
	age  int
}

func (a *A) SayOk() {
	fmt.Println("A SayOk", a.Name)
}

func (a *A) hello() {
	fmt.Println("A hello", a.Name)
}

//-------------------------------------------- 父类2 -------------------------------------------------------------------
type C struct {
	Name string
	age  int
}

//-------------------------------------------- 父类3 -------------------------------------------------------------------
type D struct {
	Address string
}

//-------------------------------------------- 子类(多重继承) -----------------------------------------------------------
//注意：尽量不要使用多重继承，多重继承容易造成混乱
type B struct {
	A      //匿名结构体
	C      //匿名结构体
	d    D //有名结构体（go中称为“组合”）
	Name string
}

func (b *B) SayOk() {
	fmt.Println("B SayOk", b.Name)
}

func main() {

	//1.结构体B 可以使用嵌套匿名结构体A的所有字段和方法（不管首字母是否大小写）
	var b1 B
	b1.A.Name = "tom"
	b1.A.age = 19
	b1.A.SayOk()
	b1.A.hello()

	fmt.Println("----------------------------------------------------")

	//上面的写法可以简化（就近原则）
	var b2 B
	b2.Name = "smith" //先看B结构体中是否有，有就用自己的，没用就用嵌套匿名结构体A的 会一直往上层找，都找不到会报错
	b2.A.age = 20     //如果B没有age字段，而A 和 C有age, 这时就必须通过指定匿名结构体名字来区分,这个规则对方法也是一样的
	b2.SayOk()        //先看B结构体中是否有，有就用自己的，没用就用嵌套匿名结构体A的 会一直往上层找，都找不到会报错
	b2.hello()
	fmt.Println("----------------------------------------------------")

	var b3 B
	b3.Name = "jack"    //B
	b3.A.Name = "scott" //A
	b3.C.age = 100      //C
	b3.SayOk()          //  B SayOk  jack
	b3.A.SayOk()        //  A SayOk scott
	b3.hello()          //  A hello scott   特别注意此处
	b3.d.Address = "北京" //如果结构体中有一个有名结构体，则访问有名结构体的字段时，就必须带上有名结构体的名字
}
