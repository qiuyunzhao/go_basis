1.  主线程退出了，即使协程没有执行完，也会退出

2.  管道channel 本质是一个“队列”  FIFO
3.  channel设计的本身是线程安全的，不需要加锁，同一时间内只能有一个goroutine对管道进行存取操作
4.  channel有类型，一个int类型的channel只能存放int类型的数据；
    如果想存储多种类型可以定义为interface{}空接口类型，因为取出时赋值要进行类型断言，不建议（可以定义多个不同类型的channel实现）

5.  管道关闭后不能再写入数据，但是可以取出数据；
     close(c chan<- Type)函数由发送者执行，不应由接受者执行
     对于已经关闭的通道，语句： v,ok := <-c ，ok为false

6.	for range遍历时，如果channel没有关闭，则可能会出现deadlock的错误
  	for range遍历时，如果channel已经关闭，则会正常遍历取出所有数据后，就会退出遍历


7.  如果往管道里边只写不读，超过容量后会死锁报错
    如果写入速度比读取速度快，管道存满后不会死锁报错，而是写入会等待读取后再写入（阻塞式）

8.  管道是阻塞式的，如果读取时管道内没有数据，会阻塞等待

9.  默认情况管道是 双向的-“可读可写”，Go支持设置管道为 “只读” 或者 “只写”

10. 在实际开发中，可能我们不好确定什么时候关闭该管道但，可又需要遍历管道时。以使用select 方式可以解决

11.子协程阻塞不会报错，主协程阻塞会报deadlock(待验证)